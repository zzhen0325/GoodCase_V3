# Gooodcase æ¶æ„è®¾è®¡æ–‡æ¡£

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
2. [æŠ€æœ¯æ¶æ„](#æŠ€æœ¯æ¶æ„)
3. [æ¨¡å—è®¾è®¡](#æ¨¡å—è®¾è®¡)
4. [ç»„ä»¶æ¶æ„](#ç»„ä»¶æ¶æ„)
5. [æ•°æ®æµæ¶æ„](#æ•°æ®æµæ¶æ„)
6. [çŠ¶æ€ç®¡ç†](#çŠ¶æ€ç®¡ç†)
7. [è·¯ç”±è®¾è®¡](#è·¯ç”±è®¾è®¡)
8. [æ€§èƒ½æ¶æ„](#æ€§èƒ½æ¶æ„)
9. [å®‰å…¨æ¶æ„](#å®‰å…¨æ¶æ„)
10. [éƒ¨ç½²æ¶æ„](#éƒ¨ç½²æ¶æ„)

---

## ç³»ç»Ÿæ¦‚è¿°

### ğŸ¯ é¡¹ç›®å®šä½

**Gooodcase** æ˜¯ä¸€ä¸ªç°ä»£åŒ–çš„å›¾ç‰‡ç®¡ç†å’Œå±•ç¤ºå¹³å°ï¼Œä¸“æ³¨äºä¸ºç”¨æˆ·æä¾›é«˜æ•ˆçš„å›¾ç‰‡ç»„ç»‡ã€æ ‡ç­¾ç®¡ç†å’Œæ™ºèƒ½æœç´¢åŠŸèƒ½ã€‚

### ğŸ—ï¸ æ¶æ„åŸåˆ™

1. **æ¨¡å—åŒ–è®¾è®¡**: é«˜å†…èšã€ä½è€¦åˆçš„æ¨¡å—åˆ’åˆ†
2. **ç»„ä»¶åŒ–å¼€å‘**: å¯å¤ç”¨çš„ React ç»„ä»¶ä½“ç³»
3. **å“åº”å¼æ¶æ„**: é€‚é…å¤šç§è®¾å¤‡å’Œå±å¹•å°ºå¯¸
4. **æ€§èƒ½ä¼˜å…ˆ**: ä¼˜åŒ–åŠ è½½é€Ÿåº¦å’Œç”¨æˆ·ä½“éªŒ
5. **å¯æ‰©å±•æ€§**: æ”¯æŒåŠŸèƒ½æ‰©å±•å’Œä¸šåŠ¡å¢é•¿
6. **ç±»å‹å®‰å…¨**: å…¨é¢çš„ TypeScript ç±»å‹å®šä¹‰

### ğŸ“Š ç³»ç»Ÿç‰¹æ€§

- âœ… **å®æ—¶æ•°æ®åŒæ­¥**: Firebase Firestore å®æ—¶ç›‘å¬
- âœ… **ç¦»çº¿æ”¯æŒ**: PWA ç‰¹æ€§å’Œæœ¬åœ°ç¼“å­˜
- âœ… **å“åº”å¼è®¾è®¡**: ç§»åŠ¨ç«¯å’Œæ¡Œé¢ç«¯é€‚é…
- âœ… **æ— é™æ»šåŠ¨**: é«˜æ€§èƒ½çš„å›¾ç‰‡åˆ—è¡¨åŠ è½½
- âœ… **æ™ºèƒ½æœç´¢**: å¤šç»´åº¦æœç´¢å’Œè¿‡æ»¤
- âœ… **æ‰¹é‡æ“ä½œ**: é«˜æ•ˆçš„æ‰¹é‡ç®¡ç†åŠŸèƒ½
- âœ… **ä¸»é¢˜åˆ‡æ¢**: æ·±è‰²/æµ…è‰²ä¸»é¢˜æ”¯æŒ

---

## æŠ€æœ¯æ¶æ„

### ğŸ› ï¸ æŠ€æœ¯æ ˆæ¦‚è§ˆ

```mermaid
graph TB
    subgraph "å‰ç«¯æŠ€æœ¯æ ˆ"
        A[Next.js 14] --> B[React 18]
        B --> C[TypeScript]
        C --> D[Tailwind CSS]
        D --> E[Framer Motion]
        E --> F[Radix UI]
    end
    
    subgraph "çŠ¶æ€ç®¡ç†"
        G[React Hooks] --> H[Context API]
        H --> I[Custom Hooks]
    end
    
    subgraph "åç«¯æœåŠ¡"
        J[Firebase Auth] --> K[Firestore]
        K --> L[Firebase Storage]
        L --> M[Firebase Hosting]
    end
    
    subgraph "å¼€å‘å·¥å…·"
        N[ESLint] --> O[Prettier]
        O --> P[Husky]
        P --> Q[TypeScript]
    end
    
    A --> G
    A --> J
    C --> N
```

### ğŸ›ï¸ åˆ†å±‚æ¶æ„

```mermaid
graph TD
    subgraph "è¡¨ç°å±‚ (Presentation Layer)"
        A1[é¡µé¢ç»„ä»¶ Pages]
        A2[å¸ƒå±€ç»„ä»¶ Layouts]
        A3[UI ç»„ä»¶ Components]
    end
    
    subgraph "ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic Layer)"
        B1[è‡ªå®šä¹‰ Hooks]
        B2[çŠ¶æ€ç®¡ç† State]
        B3[ä¸šåŠ¡é€»è¾‘ Logic]
    end
    
    subgraph "æ•°æ®è®¿é—®å±‚ (Data Access Layer)"
        C1[æ•°æ®åº“æ“ä½œ Database]
        C2[API æ¥å£ API]
        C3[ç¼“å­˜ç®¡ç† Cache]
    end
    
    subgraph "åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)"
        D1[Firebase Services]
        D2[ç¬¬ä¸‰æ–¹æœåŠ¡ 3rd Party]
        D3[å·¥å…·å‡½æ•° Utils]
    end
    
    A1 --> B1
    A2 --> B2
    A3 --> B3
    B1 --> C1
    B2 --> C2
    B3 --> C3
    C1 --> D1
    C2 --> D2
    C3 --> D3
```

### ğŸ”§ æ ¸å¿ƒæŠ€æœ¯é€‰å‹

| æŠ€æœ¯é¢†åŸŸ | é€‰å‹ | ç‰ˆæœ¬ | é€‰æ‹©ç†ç”± |
|---------|------|------|----------|
| **å‰ç«¯æ¡†æ¶** | Next.js | 14.x | SSR/SSG æ”¯æŒï¼Œä¼˜ç§€çš„æ€§èƒ½ä¼˜åŒ– |
| **UI åº“** | React | 18.x | æˆç†Ÿçš„ç»„ä»¶åŒ–å¼€å‘ä½“éªŒ |
| **ç±»å‹ç³»ç»Ÿ** | TypeScript | 5.x | ç±»å‹å®‰å…¨ï¼Œæå‡å¼€å‘æ•ˆç‡ |
| **æ ·å¼æ–¹æ¡ˆ** | Tailwind CSS | 3.x | åŸå­åŒ– CSSï¼Œå¿«é€Ÿå¼€å‘ |
| **åŠ¨ç”»åº“** | Framer Motion | 10.x | å£°æ˜å¼åŠ¨ç”»ï¼Œæ€§èƒ½ä¼˜ç§€ |
| **ç»„ä»¶åº“** | Radix UI | 1.x | æ— æ ·å¼ç»„ä»¶ï¼Œå¯è®¿é—®æ€§å¥½ |
| **æ•°æ®åº“** | Firestore | 9.x | å®æ—¶åŒæ­¥ï¼ŒNoSQL çµæ´»æ€§ |
| **å­˜å‚¨** | Firebase Storage | 9.x | æ–‡ä»¶å­˜å‚¨ï¼ŒCDN åŠ é€Ÿ |
| **éƒ¨ç½²** | Vercel | - | é›¶é…ç½®éƒ¨ç½²ï¼Œè¾¹ç¼˜è®¡ç®— |

---

## æ¨¡å—è®¾è®¡

### ğŸ“¦ æ¨¡å—åˆ’åˆ†

```
src/
â”œâ”€â”€ app/                    # Next.js App Router
â”‚   â”œâ”€â”€ globals.css        # å…¨å±€æ ·å¼
â”‚   â”œâ”€â”€ layout.tsx         # æ ¹å¸ƒå±€
â”‚   â”œâ”€â”€ page.tsx           # é¦–é¡µ
â”‚   â””â”€â”€ api/               # API è·¯ç”±
â”œâ”€â”€ components/            # ç»„ä»¶æ¨¡å—
â”‚   â”œâ”€â”€ ui/               # åŸºç¡€ UI ç»„ä»¶
â”‚   â”œâ”€â”€ business/         # ä¸šåŠ¡ç»„ä»¶
â”‚   â””â”€â”€ layout/           # å¸ƒå±€ç»„ä»¶
â”œâ”€â”€ hooks/                # è‡ªå®šä¹‰ Hooks
â”œâ”€â”€ lib/                  # å·¥å…·åº“
â”‚   â”œâ”€â”€ database.ts       # æ•°æ®åº“æ“ä½œ
â”‚   â”œâ”€â”€ firebase.ts       # Firebase é…ç½®
â”‚   â””â”€â”€ utils.ts          # å·¥å…·å‡½æ•°
â”œâ”€â”€ types/                # ç±»å‹å®šä¹‰
â””â”€â”€ constants/            # å¸¸é‡å®šä¹‰
```

### ğŸ§© æ ¸å¿ƒæ¨¡å—è¯¦è§£

#### 1. é¡µé¢æ¨¡å— (Pages)

```typescript
// app/page.tsx - ä¸»é¡µé¢
export default function HomePage() {
  const {
    // çŠ¶æ€
    images, tags, tagGroups, isLoading,
    // æ“ä½œ
    handleImageUpload, handleTagCreate, handleSearch,
    // UI çŠ¶æ€
    selectedImages, editMode, modalState
  } = useHomePage();
  
  return (
    <div className="min-h-screen bg-background">
      <AppSidebar />
      <main className="pl-64">
        <SearchBar onSearch={handleSearch} />
        <ImageGrid 
          images={images}
          selectedImages={selectedImages}
          editMode={editMode}
        />
      </main>
    </div>
  );
}
```

#### 2. ç»„ä»¶æ¨¡å— (Components)

##### åŸºç¡€ UI ç»„ä»¶
```typescript
// components/ui/button.tsx
interface ButtonProps {
  variant: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size: 'default' | 'sm' | 'lg' | 'icon';
  children: React.ReactNode;
}

export const Button = ({ variant, size, children, ...props }: ButtonProps) => {
  return (
    <button
      className={cn(buttonVariants({ variant, size }))}
      {...props}
    >
      {children}
    </button>
  );
};
```

##### ä¸šåŠ¡ç»„ä»¶
```typescript
// components/image-card.tsx
interface ImageCardProps {
  image: ImageData;
  selected: boolean;
  editMode: boolean;
  onSelect: (id: string) => void;
  onEdit: (image: ImageData) => void;
}

export const ImageCard = ({ image, selected, editMode, onSelect, onEdit }: ImageCardProps) => {
  return (
    <motion.div
      layout
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      className={cn(
        "relative group cursor-pointer rounded-lg overflow-hidden",
        selected && "ring-2 ring-primary"
      )}
    >
      <Image
        src={image.url}
        alt={image.title}
        width={image.width}
        height={image.height}
        className="w-full h-auto"
      />
      {editMode && (
        <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
          <Checkbox checked={selected} onCheckedChange={() => onSelect(image.id)} />
        </div>
      )}
    </motion.div>
  );
};
```

#### 3. Hooks æ¨¡å—

```typescript
// hooks/use-image-state.ts
export const useImageState = () => {
  const [images, setImages] = useState<ImageData[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // å®æ—¶ç›‘å¬å›¾ç‰‡æ•°æ®
  useEffect(() => {
    const unsubscribe = database.subscribeToImages(
      (newImages) => {
        setImages(newImages);
        setLoading(false);
      },
      (error) => {
        setError(error.message);
        setLoading(false);
      }
    );
    
    return unsubscribe;
  }, []);
  
  return { images, loading, error, setImages };
};
```

#### 4. æ•°æ®è®¿é—®æ¨¡å—

```typescript
// lib/database.ts
export class Database {
  private db: Firestore;
  
  constructor() {
    this.db = getFirestore();
  }
  
  // å®æ—¶ç›‘å¬å›¾ç‰‡æ•°æ®
  subscribeToImages(
    onSuccess: (images: ImageData[]) => void,
    onError: (error: Error) => void
  ): Unsubscribe {
    const q = query(
      collection(this.db, 'images'),
      orderBy('createdAt', 'desc')
    );
    
    return onSnapshot(q, 
      (snapshot) => {
        const images = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as ImageData[];
        onSuccess(images);
      },
      onError
    );
  }
  
  // æ·»åŠ å›¾ç‰‡
  async addImage(imageData: Omit<ImageData, 'id'>): Promise<string> {
    const docRef = await addDoc(collection(this.db, 'images'), {
      ...imageData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    return docRef.id;
  }
}
```

---

## ç»„ä»¶æ¶æ„

### ğŸ—ï¸ ç»„ä»¶å±‚æ¬¡ç»“æ„

```mermaid
graph TD
    A[App Layout] --> B[Sidebar]
    A --> C[Main Content]
    
    B --> D[Navigation]
    B --> E[Tag Manager]
    B --> F[Settings]
    
    C --> G[Search Bar]
    C --> H[Image Grid]
    C --> I[Modal System]
    
    H --> J[Image Card]
    H --> K[Infinite Scroll]
    
    I --> L[Image Detail Modal]
    I --> M[Upload Modal]
    I --> N[Tag Edit Modal]
    
    J --> O[Image Display]
    J --> P[Tag List]
    J --> Q[Action Buttons]
```

### ğŸ¨ ç»„ä»¶è®¾è®¡æ¨¡å¼

#### 1. å¤åˆç»„ä»¶æ¨¡å¼ (Compound Components)

```typescript
// components/tag-manager/index.tsx
interface TagManagerProps {
  children: React.ReactNode;
}

const TagManager = ({ children }: TagManagerProps) => {
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  
  return (
    <TagManagerContext.Provider value={{ selectedTags, setSelectedTags }}>
      <div className="tag-manager">
        {children}
      </div>
    </TagManagerContext.Provider>
  );
};

// å­ç»„ä»¶
TagManager.Header = TagManagerHeader;
TagManager.List = TagManagerList;
TagManager.Item = TagManagerItem;
TagManager.Actions = TagManagerActions;

// ä½¿ç”¨æ–¹å¼
<TagManager>
  <TagManager.Header title="æ ‡ç­¾ç®¡ç†" />
  <TagManager.List>
    {tags.map(tag => (
      <TagManager.Item key={tag.id} tag={tag} />
    ))}
  </TagManager.List>
  <TagManager.Actions />
</TagManager>
```

#### 2. æ¸²æŸ“å±æ€§æ¨¡å¼ (Render Props)

```typescript
// components/infinite-scroll.tsx
interface InfiniteScrollProps<T> {
  items: T[];
  loadMore: () => Promise<void>;
  hasMore: boolean;
  loading: boolean;
  children: (item: T, index: number) => React.ReactNode;
}

export const InfiniteScroll = <T,>({
  items,
  loadMore,
  hasMore,
  loading,
  children
}: InfiniteScrollProps<T>) => {
  const { ref, inView } = useInView();
  
  useEffect(() => {
    if (inView && hasMore && !loading) {
      loadMore();
    }
  }, [inView, hasMore, loading, loadMore]);
  
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
      {items.map((item, index) => children(item, index))}
      {hasMore && (
        <div ref={ref} className="col-span-full flex justify-center p-4">
          {loading && <Spinner />}
        </div>
      )}
    </div>
  );
};

// ä½¿ç”¨æ–¹å¼
<InfiniteScroll
  items={images}
  loadMore={loadMoreImages}
  hasMore={hasMoreImages}
  loading={loading}
>
  {(image, index) => (
    <ImageCard
      key={image.id}
      image={image}
      selected={selectedImages.includes(image.id)}
      onSelect={handleImageSelect}
    />
  )}
</InfiniteScroll>
```

#### 3. é«˜é˜¶ç»„ä»¶æ¨¡å¼ (HOC)

```typescript
// hoc/with-loading.tsx
interface WithLoadingProps {
  loading: boolean;
}

export const withLoading = <P extends object>(
  Component: React.ComponentType<P>
) => {
  return (props: P & WithLoadingProps) => {
    const { loading, ...restProps } = props;
    
    if (loading) {
      return (
        <div className="flex items-center justify-center p-8">
          <Spinner size="lg" />
        </div>
      );
    }
    
    return <Component {...(restProps as P)} />;
  };
};

// ä½¿ç”¨æ–¹å¼
const ImageGridWithLoading = withLoading(ImageGrid);

<ImageGridWithLoading
  images={images}
  loading={loading}
  onImageSelect={handleImageSelect}
/>
```

### ğŸ”„ ç»„ä»¶é€šä¿¡æ¨¡å¼

#### 1. Props ä¼ é€’
```typescript
// çˆ¶ç»„ä»¶å‘å­ç»„ä»¶ä¼ é€’æ•°æ®
<ImageCard
  image={image}
  selected={selected}
  onSelect={onSelect}
  onEdit={onEdit}
/>
```

#### 2. Context å…±äº«çŠ¶æ€
```typescript
// contexts/app-context.tsx
interface AppContextType {
  theme: 'light' | 'dark';
  setTheme: (theme: 'light' | 'dark') => void;
  user: User | null;
  setUser: (user: User | null) => void;
}

export const AppContext = createContext<AppContextType | undefined>(undefined);

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within AppProvider');
  }
  return context;
};
```

#### 3. äº‹ä»¶æ€»çº¿
```typescript
// lib/event-bus.ts
class EventBus {
  private events: Map<string, Function[]> = new Map();
  
  on(event: string, callback: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback);
  }
  
  emit(event: string, data?: any) {
    const callbacks = this.events.get(event);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }
  
  off(event: string, callback: Function) {
    const callbacks = this.events.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }
}

export const eventBus = new EventBus();
```

---

## æ•°æ®æµæ¶æ„

### ğŸŒŠ æ•°æ®æµå‘å›¾

```mermaid
flowchart TD
    A[ç”¨æˆ·æ“ä½œ] --> B[äº‹ä»¶å¤„ç†å™¨]
    B --> C[ä¸šåŠ¡é€»è¾‘ Hook]
    C --> D[æ•°æ®åº“æ“ä½œ]
    D --> E[Firestore]
    E --> F[å®æ—¶ç›‘å¬å™¨]
    F --> G[çŠ¶æ€æ›´æ–°]
    G --> H[ç»„ä»¶é‡æ¸²æŸ“]
    H --> I[UI æ›´æ–°]
    
    subgraph "å®¢æˆ·ç«¯ç¼“å­˜"
        J[å†…å­˜ç¼“å­˜]
        K[æœ¬åœ°å­˜å‚¨]
        L[IndexedDB]
    end
    
    F --> J
    J --> G
    
    subgraph "é”™è¯¯å¤„ç†"
        M[é”™è¯¯è¾¹ç•Œ]
        N[é”™è¯¯æ—¥å¿—]
        O[ç”¨æˆ·æç¤º]
    end
    
    D --> M
    M --> N
    M --> O
```

### ğŸ“Š çŠ¶æ€ç®¡ç†æ¶æ„

#### 1. å…¨å±€çŠ¶æ€ç»“æ„

```typescript
// types/app-state.ts
interface AppState {
  // æ•°æ®çŠ¶æ€
  images: ImageData[];
  tags: Tag[];
  tagGroups: TagGroup[];
  
  // UI çŠ¶æ€
  selectedImages: string[];
  editMode: boolean;
  searchQuery: string;
  searchFilters: SearchFilters;
  
  // æ¨¡æ€æ¡†çŠ¶æ€
  modals: {
    imageDetail: { open: boolean; imageId?: string };
    upload: { open: boolean };
    tagEdit: { open: boolean; tagId?: string };
  };
  
  // åŠ è½½çŠ¶æ€
  loading: {
    images: boolean;
    tags: boolean;
    upload: boolean;
  };
  
  // é”™è¯¯çŠ¶æ€
  errors: {
    images?: string;
    tags?: string;
    upload?: string;
  };
  
  // ç¼“å­˜çŠ¶æ€
  cache: {
    lastFetch: Record<string, number>;
    invalidated: string[];
  };
  
  // æ€§èƒ½æŒ‡æ ‡
  performance: {
    loadTime: number;
    renderTime: number;
    cacheHitRate: number;
  };
}
```

#### 2. çŠ¶æ€æ›´æ–°æ¨¡å¼

```typescript
// hooks/use-app-state.ts
export const useAppState = () => {
  const [state, setState] = useState<AppState>(initialState);
  
  // çŠ¶æ€æ›´æ–°å‡½æ•°
  const updateState = useCallback((updates: Partial<AppState>) => {
    setState(prev => ({ ...prev, ...updates }));
  }, []);
  
  // æ‰¹é‡çŠ¶æ€æ›´æ–°
  const batchUpdate = useCallback((updates: Array<Partial<AppState>>) => {
    setState(prev => {
      return updates.reduce((acc, update) => ({ ...acc, ...update }), prev);
    });
  }, []);
  
  // é‡ç½®çŠ¶æ€
  const resetState = useCallback(() => {
    setState(initialState);
  }, []);
  
  return {
    state,
    updateState,
    batchUpdate,
    resetState
  };
};
```

#### 3. æ•°æ®åŒæ­¥ç­–ç•¥

```typescript
// hooks/use-data-sync.ts
export const useDataSync = () => {
  const { state, updateState } = useAppState();
  const [syncStatus, setSyncStatus] = useState<'idle' | 'syncing' | 'error'>('idle');
  
  // å®æ—¶æ•°æ®åŒæ­¥
  useEffect(() => {
    setSyncStatus('syncing');
    
    const unsubscribeImages = database.subscribeToImages(
      (images) => {
        updateState({ 
          images,
          loading: { ...state.loading, images: false }
        });
        setSyncStatus('idle');
      },
      (error) => {
        updateState({
          errors: { ...state.errors, images: error.message },
          loading: { ...state.loading, images: false }
        });
        setSyncStatus('error');
      }
    );
    
    const unsubscribeTags = database.subscribeToTags(
      (tags) => {
        updateState({ 
          tags,
          loading: { ...state.loading, tags: false }
        });
      },
      (error) => {
        updateState({
          errors: { ...state.errors, tags: error.message },
          loading: { ...state.loading, tags: false }
        });
      }
    );
    
    return () => {
      unsubscribeImages();
      unsubscribeTags();
    };
  }, []);
  
  return { syncStatus };
};
```

---

## è·¯ç”±è®¾è®¡

### ğŸ›£ï¸ è·¯ç”±æ¶æ„

```typescript
// Next.js App Router ç»“æ„
app/
â”œâ”€â”€ layout.tsx              # æ ¹å¸ƒå±€
â”œâ”€â”€ page.tsx               # é¦–é¡µ (/)
â”œâ”€â”€ loading.tsx            # åŠ è½½é¡µé¢
â”œâ”€â”€ error.tsx              # é”™è¯¯é¡µé¢
â”œâ”€â”€ not-found.tsx          # 404 é¡µé¢
â”œâ”€â”€ api/                   # API è·¯ç”±
â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â”œâ”€â”€ route.ts       # GET /api/images
â”‚   â”‚   â””â”€â”€ [id]/
â”‚   â”‚       â””â”€â”€ route.ts   # GET/PUT/DELETE /api/images/[id]
â”‚   â”œâ”€â”€ tags/
â”‚   â”‚   â””â”€â”€ route.ts       # GET/POST /api/tags
â”‚   â””â”€â”€ upload/
â”‚       â””â”€â”€ route.ts       # POST /api/upload
â””â”€â”€ (dashboard)/           # è·¯ç”±ç»„
    â”œâ”€â”€ layout.tsx         # ä»ªè¡¨æ¿å¸ƒå±€
    â”œâ”€â”€ images/
    â”‚   â”œâ”€â”€ page.tsx       # /images
    â”‚   â””â”€â”€ [id]/
    â”‚       â””â”€â”€ page.tsx   # /images/[id]
    â”œâ”€â”€ tags/
    â”‚   â””â”€â”€ page.tsx       # /tags
    â””â”€â”€ settings/
        â””â”€â”€ page.tsx       # /settings
```

### ğŸ”— è·¯ç”±é…ç½®

```typescript
// lib/routes.ts
export const routes = {
  home: '/',
  images: {
    list: '/images',
    detail: (id: string) => `/images/${id}`,
    edit: (id: string) => `/images/${id}/edit`
  },
  tags: {
    list: '/tags',
    detail: (id: string) => `/tags/${id}`
  },
  settings: '/settings',
  api: {
    images: '/api/images',
    tags: '/api/tags',
    upload: '/api/upload'
  }
} as const;

// è·¯ç”±å®ˆå«
export const withAuth = (Component: React.ComponentType) => {
  return function AuthenticatedComponent(props: any) {
    const { user, loading } = useAuth();
    
    if (loading) {
      return <LoadingSpinner />;
    }
    
    if (!user) {
      redirect('/login');
    }
    
    return <Component {...props} />;
  };
};
```

### ğŸ“± å¯¼èˆªç®¡ç†

```typescript
// hooks/use-navigation.ts
export const useNavigation = () => {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  
  // å¯¼èˆªåˆ°æŒ‡å®šé¡µé¢
  const navigateTo = useCallback((path: string, options?: { replace?: boolean }) => {
    if (options?.replace) {
      router.replace(path);
    } else {
      router.push(path);
    }
  }, [router]);
  
  // è¿”å›ä¸Šä¸€é¡µ
  const goBack = useCallback(() => {
    router.back();
  }, [router]);
  
  // æ›´æ–°æŸ¥è¯¢å‚æ•°
  const updateSearchParams = useCallback((params: Record<string, string>) => {
    const newSearchParams = new URLSearchParams(searchParams);
    
    Object.entries(params).forEach(([key, value]) => {
      if (value) {
        newSearchParams.set(key, value);
      } else {
        newSearchParams.delete(key);
      }
    });
    
    router.push(`${pathname}?${newSearchParams.toString()}`);
  }, [pathname, searchParams, router]);
  
  return {
    pathname,
    searchParams,
    navigateTo,
    goBack,
    updateSearchParams
  };
};
```

---

## æ€§èƒ½æ¶æ„

### âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 1. ä»£ç åˆ†å‰²

```typescript
// åŠ¨æ€å¯¼å…¥ç»„ä»¶
const ImageDetailModal = dynamic(() => import('./image-detail-modal'), {
  loading: () => <ModalSkeleton />,
  ssr: false
});

const TagManager = dynamic(() => import('./tag-manager'), {
  loading: () => <div>åŠ è½½ä¸­...</div>
});

// è·¯ç”±çº§åˆ«çš„ä»£ç åˆ†å‰²
const SettingsPage = dynamic(() => import('./settings/page'), {
  loading: () => <PageSkeleton />
});
```

#### 2. å›¾ç‰‡ä¼˜åŒ–

```typescript
// components/optimized-image.tsx
interface OptimizedImageProps {
  src: string;
  alt: string;
  width: number;
  height: number;
  priority?: boolean;
  placeholder?: 'blur' | 'empty';
}

export const OptimizedImage = ({
  src,
  alt,
  width,
  height,
  priority = false,
  placeholder = 'blur'
}: OptimizedImageProps) => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(false);
  
  return (
    <div className="relative overflow-hidden">
      {isLoading && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
      <Image
        src={src}
        alt={alt}
        width={width}
        height={height}
        priority={priority}
        placeholder={placeholder}
        className={cn(
          "transition-opacity duration-300",
          isLoading ? "opacity-0" : "opacity-100"
        )}
        onLoad={() => setIsLoading(false)}
        onError={() => setError(true)}
      />
      {error && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-100">
          <ImageIcon className="w-8 h-8 text-gray-400" />
        </div>
      )}
    </div>
  );
};
```

#### 3. è™šæ‹Ÿæ»šåŠ¨

```typescript
// components/virtual-grid.tsx
interface VirtualGridProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
}

export const VirtualGrid = <T,>({
  items,
  itemHeight,
  containerHeight,
  renderItem
}: VirtualGridProps<T>) => {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleStart = Math.floor(scrollTop / itemHeight);
  const visibleEnd = Math.min(
    visibleStart + Math.ceil(containerHeight / itemHeight) + 1,
    items.length
  );
  
  const visibleItems = items.slice(visibleStart, visibleEnd);
  
  return (
    <div
      className="overflow-auto"
      style={{ height: containerHeight }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map((item, index) => (
          <div
            key={visibleStart + index}
            style={{
              position: 'absolute',
              top: (visibleStart + index) * itemHeight,
              height: itemHeight,
              width: '100%'
            }}
          >
            {renderItem(item, visibleStart + index)}
          </div>
        ))}
      </div>
    </div>
  );
};
```

#### 4. ç¼“å­˜ç­–ç•¥

```typescript
// lib/cache.ts
class CacheManager {
  private memoryCache = new Map<string, { data: any; timestamp: number; ttl: number }>();
  private persistentCache: IDBDatabase | null = null;
  
  constructor() {
    this.initPersistentCache();
  }
  
  // å†…å­˜ç¼“å­˜
  setMemoryCache(key: string, data: any, ttl: number = 5 * 60 * 1000) {
    this.memoryCache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  
  getMemoryCache(key: string) {
    const cached = this.memoryCache.get(key);
    if (!cached) return null;
    
    if (Date.now() - cached.timestamp > cached.ttl) {
      this.memoryCache.delete(key);
      return null;
    }
    
    return cached.data;
  }
  
  // æŒä¹…åŒ–ç¼“å­˜ (IndexedDB)
  async setPersistentCache(key: string, data: any) {
    if (!this.persistentCache) return;
    
    const transaction = this.persistentCache.transaction(['cache'], 'readwrite');
    const store = transaction.objectStore('cache');
    
    await store.put({
      key,
      data,
      timestamp: Date.now()
    });
  }
  
  async getPersistentCache(key: string) {
    if (!this.persistentCache) return null;
    
    const transaction = this.persistentCache.transaction(['cache'], 'readonly');
    const store = transaction.objectStore('cache');
    const result = await store.get(key);
    
    return result?.data || null;
  }
  
  private async initPersistentCache() {
    return new Promise<void>((resolve, reject) => {
      const request = indexedDB.open('AppCache', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.persistentCache = request.result;
        resolve();
      };
      
      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains('cache')) {
          db.createObjectStore('cache', { keyPath: 'key' });
        }
      };
    });
  }
}

export const cacheManager = new CacheManager();
```

---

## å®‰å…¨æ¶æ„

### ğŸ”’ å®‰å…¨ç­–ç•¥

#### 1. è¾“å…¥éªŒè¯

```typescript
// lib/validation.ts
import { z } from 'zod';

// å›¾ç‰‡æ•°æ®éªŒè¯
export const imageSchema = z.object({
  url: z.string().url('æ— æ•ˆçš„å›¾ç‰‡URL'),
  title: z.string().min(1, 'æ ‡é¢˜ä¸èƒ½ä¸ºç©º').max(100, 'æ ‡é¢˜è¿‡é•¿'),
  tags: z.array(z.object({
    id: z.string(),
    name: z.string().min(1, 'æ ‡ç­¾åä¸èƒ½ä¸ºç©º'),
    color: z.string().regex(/^#[0-9A-F]{6}$/i, 'æ— æ•ˆçš„é¢œè‰²æ ¼å¼')
  })),
  width: z.number().positive('å®½åº¦å¿…é¡»ä¸ºæ­£æ•°'),
  height: z.number().positive('é«˜åº¦å¿…é¡»ä¸ºæ­£æ•°')
});

// æ–‡ä»¶ä¸Šä¼ éªŒè¯
export const fileUploadSchema = z.object({
  file: z.instanceof(File)
    .refine(file => file.size <= 10 * 1024 * 1024, 'æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡10MB')
    .refine(file => ['image/jpeg', 'image/png', 'image/gif', 'image/webp'].includes(file.type), 'ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼')
});

// éªŒè¯å‡½æ•°
export const validateInput = <T>(schema: z.ZodSchema<T>, data: unknown): { success: boolean; data?: T; errors?: string[] } => {
  try {
    const validatedData = schema.parse(data);
    return { success: true, data: validatedData };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        errors: error.errors.map(err => err.message)
      };
    }
    return { success: false, errors: ['éªŒè¯å¤±è´¥'] };
  }
};
```

#### 2. XSS é˜²æŠ¤

```typescript
// lib/sanitize.ts
import DOMPurify from 'dompurify';

// HTML å†…å®¹æ¸…ç†
export const sanitizeHtml = (html: string): string => {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'u'],
    ALLOWED_ATTR: [],
    KEEP_CONTENT: true
  });
};

// ç”¨æˆ·è¾“å…¥æ¸…ç†
export const sanitizeUserInput = (input: string): string => {
  return input
    .trim()
    .replace(/[<>"'&]/g, (char) => {
      const entities: Record<string, string> = {
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '&': '&amp;'
      };
      return entities[char] || char;
    });
};

// å®‰å…¨çš„ç»„ä»¶
interface SafeHtmlProps {
  html: string;
  className?: string;
}

export const SafeHtml = ({ html, className }: SafeHtmlProps) => {
  const sanitizedHtml = sanitizeHtml(html);
  
  return (
    <div
      className={className}
      dangerouslySetInnerHTML={{ __html: sanitizedHtml }}
    />
  );
};
```

#### 3. CSRF é˜²æŠ¤

```typescript
// lib/csrf.ts
export const generateCSRFToken = (): string => {
  return crypto.randomUUID();
};

export const validateCSRFToken = (token: string, sessionToken: string): boolean => {
  return token === sessionToken;
};

// API è·¯ç”±ä¸­çš„ CSRF éªŒè¯
export const withCSRFProtection = (handler: NextApiHandler): NextApiHandler => {
  return async (req, res) => {
    if (req.method !== 'GET') {
      const token = req.headers['x-csrf-token'] as string;
      const sessionToken = req.session?.csrfToken;
      
      if (!token || !sessionToken || !validateCSRFToken(token, sessionToken)) {
        return res.status(403).json({ error: 'Invalid CSRF token' });
      }
    }
    
    return handler(req, res);
  };
};
```

---

## éƒ¨ç½²æ¶æ„

### ğŸš€ éƒ¨ç½²ç­–ç•¥

#### 1. Vercel éƒ¨ç½²é…ç½®

```json
// vercel.json
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/next"
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "/api/$1"
    },
    {
      "src": "/(.*)",
      "dest": "/$1"
    }
  ],
  "env": {
    "NEXT_PUBLIC_FIREBASE_API_KEY": "@firebase-api-key",
    "NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN": "@firebase-auth-domain",
    "NEXT_PUBLIC_FIREBASE_PROJECT_ID": "@firebase-project-id"
  },
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        }
      ]
    }
  ]
}
```

#### 2. ç¯å¢ƒé…ç½®

```typescript
// lib/env.ts
import { z } from 'zod';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  NEXT_PUBLIC_FIREBASE_API_KEY: z.string(),
  NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN: z.string(),
  NEXT_PUBLIC_FIREBASE_PROJECT_ID: z.string(),
  NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET: z.string(),
  NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: z.string(),
  NEXT_PUBLIC_FIREBASE_APP_ID: z.string()
});

export const env = envSchema.parse(process.env);

// ç¯å¢ƒæ£€æŸ¥
export const isDevelopment = env.NODE_ENV === 'development';
export const isProduction = env.NODE_ENV === 'production';
export const isTest = env.NODE_ENV === 'test';
```

#### 3. CI/CD æµç¨‹

```yaml
# .github/workflows/deploy.yml
name: Deploy to Vercel

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - run: npm ci
      - run: npm run lint
      - run: npm run type-check
      - run: npm run test
      - run: npm run build
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      - uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID }}
          vercel-project-id: ${{ secrets.PROJECT_ID }}
          vercel-args: '--prod'
```

### ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

#### 1. æ€§èƒ½ç›‘æ§

```typescript
// lib/analytics.ts
interface PerformanceMetric {
  name: string;
  value: number;
  timestamp: number;
  url: string;
}

class Analytics {
  private metrics: PerformanceMetric[] = [];
  
  // è®°å½•æ€§èƒ½æŒ‡æ ‡
  recordMetric(name: string, value: number) {
    const metric: PerformanceMetric = {
      name,
      value,
      timestamp: Date.now(),
      url: window.location.href
    };
    
    this.metrics.push(metric);
    
    // å‘é€åˆ°åˆ†ææœåŠ¡
    this.sendToAnalytics(metric);
  }
  
  // è®°å½•é¡µé¢åŠ è½½æ—¶é—´
  recordPageLoad() {
    if (typeof window !== 'undefined') {
      window.addEventListener('load', () => {
        const loadTime = performance.now();
        this.recordMetric('page_load_time', loadTime);
      });
    }
  }
  
  // è®°å½•ç»„ä»¶æ¸²æŸ“æ—¶é—´
  recordComponentRender(componentName: string, renderTime: number) {
    this.recordMetric(`component_render_${componentName}`, renderTime);
  }
  
  private async sendToAnalytics(metric: PerformanceMetric) {
    try {
      await fetch('/api/analytics', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(metric)
      });
    } catch (error) {
      console.error('Failed to send analytics:', error);
    }
  }
}

export const analytics = new Analytics();
```

#### 2. é”™è¯¯ç›‘æ§

```typescript
// lib/error-tracking.ts
interface ErrorInfo {
  message: string;
  stack?: string;
  url: string;
  timestamp: number;
  userAgent: string;
  userId?: string;
}

class ErrorTracker {
  private errors: ErrorInfo[] = [];
  
  constructor() {
    this.setupGlobalErrorHandlers();
  }
  
  // è®°å½•é”™è¯¯
  recordError(error: Error, additionalInfo?: Record<string, any>) {
    const errorInfo: ErrorInfo = {
      message: error.message,
      stack: error.stack,
      url: typeof window !== 'undefined' ? window.location.href : '',
      timestamp: Date.now(),
      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : '',
      ...additionalInfo
    };
    
    this.errors.push(errorInfo);
    this.sendErrorToService(errorInfo);
  }
  
  // è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
  private setupGlobalErrorHandlers() {
    if (typeof window !== 'undefined') {
      window.addEventListener('error', (event) => {
        this.recordError(new Error(event.message), {
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno
        });
      });
      
      window.addEventListener('unhandledrejection', (event) => {
        this.recordError(new Error(`Unhandled Promise Rejection: ${event.reason}`));
      });
    }
  }
  
  private async sendErrorToService(errorInfo: ErrorInfo) {
    try {
      await fetch('/api/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorInfo)
      });
    } catch (error) {
      console.error('Failed to send error to service:', error);
    }
  }
}

export const errorTracker = new ErrorTracker();
```

---

## æ‰©å±•æ€§è®¾è®¡

### ğŸ”® æœªæ¥æ‰©å±•è®¡åˆ’

#### 1. å¾®å‰ç«¯æ¶æ„

```typescript
// æ¨¡å—è”é‚¦é…ç½® (webpack.config.js)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        imageEditor: 'imageEditor@http://localhost:3001/remoteEntry.js',
        analytics: 'analytics@http://localhost:3002/remoteEntry.js'
      }
    })
  ]
};

// åŠ¨æ€åŠ è½½è¿œç¨‹æ¨¡å—
const ImageEditor = React.lazy(() => import('imageEditor/ImageEditor'));
const Analytics = React.lazy(() => import('analytics/Dashboard'));
```

#### 2. æ’ä»¶ç³»ç»Ÿ

```typescript
// lib/plugin-system.ts
interface Plugin {
  name: string;
  version: string;
  init: (app: AppInstance) => void;
  destroy: () => void;
}

class PluginManager {
  private plugins = new Map<string, Plugin>();
  
  register(plugin: Plugin) {
    this.plugins.set(plugin.name, plugin);
    plugin.init(this.app);
  }
  
  unregister(pluginName: string) {
    const plugin = this.plugins.get(pluginName);
    if (plugin) {
      plugin.destroy();
      this.plugins.delete(pluginName);
    }
  }
  
  getPlugin(name: string): Plugin | undefined {
    return this.plugins.get(name);
  }
}

// æ’ä»¶ç¤ºä¾‹
const imageFilterPlugin: Plugin = {
  name: 'image-filter',
  version: '1.0.0',
  init: (app) => {
    app.addImageFilter('blur', (image) => {
      // æ¨¡ç³Šæ»¤é•œå®ç°
    });
  },
  destroy: () => {
    // æ¸…ç†èµ„æº
  }
};
```

#### 3. å›½é™…åŒ–æ”¯æŒ

```typescript
// lib/i18n.ts
import { createInstance } from 'i18next';
import { initReactI18next } from 'react-i18next';

const i18n = createInstance();

i18n
  .use(initReactI18next)
  .init({
    lng: 'zh-CN',
    fallbackLng: 'en',
    resources: {
      'zh-CN': {
        translation: {
          'image.upload': 'ä¸Šä¼ å›¾ç‰‡',
          'tag.create': 'åˆ›å»ºæ ‡ç­¾',
          'search.placeholder': 'æœç´¢å›¾ç‰‡...'
        }
      },
      'en': {
        translation: {
          'image.upload': 'Upload Image',
          'tag.create': 'Create Tag',
          'search.placeholder': 'Search images...'
        }
      }
    }
  });

export default i18n;
```

---

## æ€»ç»“

### ğŸ¯ æ¶æ„ä¼˜åŠ¿

1. **æ¨¡å—åŒ–**: æ¸…æ™°çš„æ¨¡å—åˆ’åˆ†ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
2. **ç±»å‹å®‰å…¨**: å…¨é¢çš„ TypeScript æ”¯æŒ
3. **æ€§èƒ½ä¼˜åŒ–**: å¤šå±‚æ¬¡çš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
4. **ç”¨æˆ·ä½“éªŒ**: å“åº”å¼è®¾è®¡å’Œæµç•…çš„äº¤äº’
5. **å¯æ‰©å±•æ€§**: æ”¯æŒæ’ä»¶ç³»ç»Ÿå’Œå¾®å‰ç«¯
6. **å®‰å…¨æ€§**: å¤šé‡å®‰å…¨é˜²æŠ¤æªæ–½

### ğŸ”„ æŒç»­æ”¹è¿›

- å®šæœŸæ€§èƒ½å®¡è®¡å’Œä¼˜åŒ–
- ç”¨æˆ·åé¦ˆæ”¶é›†å’Œåˆ†æ
- æŠ€æœ¯æ ˆå‡çº§å’Œè¿ç§»
- æ–°åŠŸèƒ½å¼€å‘å’Œæµ‹è¯•
- å®‰å…¨æ¼æ´ä¿®å¤å’Œé˜²æŠ¤

---

**æ–‡æ¡£ç»´æŠ¤è€…**: æ¶æ„å›¢é˜Ÿ  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2024-01-01  

*æœ¬æ–‡æ¡£å°†éšç€ç³»ç»Ÿæ¶æ„çš„æ¼”è¿›æŒç»­æ›´æ–°ã€‚*