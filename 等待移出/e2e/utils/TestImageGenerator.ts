import * as fs from 'fs';
import * as path from 'path';

/**
 * 测试图片生成器
 * 用于创建不同格式和大小的测试图片文件
 */
export class TestImageGenerator {
  private fixturesDir: string;

  constructor(fixturesDir: string) {
    this.fixturesDir = fixturesDir;
    this.ensureFixturesDir();
  }

  /**
   * 确保fixtures目录存在
   */
  private ensureFixturesDir() {
    if (!fs.existsSync(this.fixturesDir)) {
      fs.mkdirSync(this.fixturesDir, { recursive: true });
    }
  }

  /**
   * 创建PNG测试图片
   */
  createPngImage(filename: string, width: number = 200, height: number = 200): string {
    const filePath = path.join(this.fixturesDir, filename);
    
    // 使用最小的有效PNG图片（1x1像素）
    const pngData = Buffer.from([
      0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
      0x00, 0x00, 0x00, 0x0D, // IHDR length
      0x49, 0x48, 0x44, 0x52, // IHDR
      0x00, 0x00, 0x00, 0x01, // width = 1
      0x00, 0x00, 0x00, 0x01, // height = 1
      0x08, 0x02, 0x00, 0x00, 0x00, // bit depth, color type, compression, filter, interlace
      0x90, 0x77, 0x53, 0xDE, // CRC
      0x00, 0x00, 0x00, 0x0C, // IDAT length
      0x49, 0x44, 0x41, 0x54, // IDAT
      0x08, 0x99, 0x01, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, // compressed data
      0x00, 0x00, 0x00, 0x00, // IEND length
      0x49, 0x45, 0x4E, 0x44, // IEND
      0xAE, 0x42, 0x60, 0x82  // CRC
    ]);
    
    fs.writeFileSync(filePath, pngData);
    
    return filePath;
  }

  /**
   * 创建JPEG测试图片
   */
  createJpegImage(filename: string, width: number = 200, height: number = 200): string {
    const filePath = path.join(this.fixturesDir, filename);
    
    // 使用最小的有效JPEG图片（1x1像素）
    const jpegData = Buffer.from([
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
      0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
      0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
      0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
      0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
      0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
      0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
      0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x01,
      0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
      0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFF, 0xC4,
      0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C,
      0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0x80, 0x00,
      0xFF, 0xD9
    ]);
    
    fs.writeFileSync(filePath, jpegData);
    
    return filePath;
  }

  /**
   * 创建大文件测试图片（用于测试文件大小限制）
   */
  createLargeImage(filename: string, sizeInMB: number = 15): string {
    const filePath = path.join(this.fixturesDir, filename);
    
    // 创建指定大小的文件
    const sizeInBytes = sizeInMB * 1024 * 1024;
    const buffer = Buffer.alloc(sizeInBytes, 0xFF);
    
    // 添加PNG文件头
    const pngHeader = Buffer.from([
      0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A
    ]);
    
    const finalBuffer = Buffer.concat([pngHeader, buffer]);
    fs.writeFileSync(filePath, finalBuffer);
    
    return filePath;
  }

  /**
   * 创建无效格式文件（用于测试格式验证）
   */
  createInvalidFormatFile(filename: string): string {
    const filePath = path.join(this.fixturesDir, filename);
    
    // 创建一个文本文件，但使用图片扩展名
    const content = 'This is not an image file';
    fs.writeFileSync(filePath, content, 'utf8');
    
    return filePath;
  }

  /**
   * 创建WebP测试图片
   */
  createWebpImage(filename: string, width: number = 200, height: number = 200): string {
    const filePath = path.join(this.fixturesDir, filename);
    
    // 创建一个简单的WebP图片数据
    const webpData = this.generateWebpData(width, height);
    fs.writeFileSync(filePath, webpData);
    
    return filePath;
  }

  /**
   * 创建GIF测试图片
   */
  createGifImage(filename: string, width: number = 200, height: number = 200): string {
    const filePath = path.join(this.fixturesDir, filename);
    
    // 创建一个简单的GIF图片数据
    const gifData = this.generateGifData(width, height);
    fs.writeFileSync(filePath, gifData);
    
    return filePath;
  }

  /**
   * 生成PNG数据
   */
  private generatePngData(width: number, height: number): Buffer {
    // 使用一个有效的1x1像素PNG文件的二进制数据
    // 这是一个经过验证的最小PNG文件
    const validPngData = Buffer.from([
      0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
      0x00, 0x00, 0x00, 0x0D, // IHDR length
      0x49, 0x48, 0x44, 0x52, // IHDR
      0x00, 0x00, 0x00, 0x01, // width: 1
      0x00, 0x00, 0x00, 0x01, // height: 1
      0x08, 0x02, 0x00, 0x00, 0x00, // bit depth, color type, compression, filter, interlace
      0x90, 0x77, 0x53, 0xDE, // IHDR CRC
      0x00, 0x00, 0x00, 0x0C, // IDAT length
      0x49, 0x44, 0x41, 0x54, // IDAT
      0x08, 0x99, 0x01, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, // compressed data
      0x00, 0x00, 0x00, 0x00, // IEND length
      0x49, 0x45, 0x4E, 0x44, // IEND
      0xAE, 0x42, 0x60, 0x82  // IEND CRC
    ]);
    
    return validPngData;
  }

  /**
   * 创建PNG chunk
   */
  private createPngChunk(type: string, data: Buffer): Buffer {
    const length = Buffer.alloc(4);
    length.writeUInt32BE(data.length, 0);
    
    const typeBuffer = Buffer.from(type, 'ascii');
    const crc = this.calculateCRC32(Buffer.concat([typeBuffer, data]));
    const crcBuffer = Buffer.alloc(4);
    crcBuffer.writeUInt32BE(crc, 0);
    
    return Buffer.concat([length, typeBuffer, data, crcBuffer]);
  }

  /**
   * 计算CRC32（简化版）
   */
  private calculateCRC32(data: Buffer): number {
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < data.length; i++) {
      crc ^= data[i];
      for (let j = 0; j < 8; j++) {
        crc = (crc >>> 1) ^ (crc & 1 ? 0xEDB88320 : 0);
      }
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
  }

  /**
   * 生成JPEG数据（使用有效的最小JPEG文件）
   */
  private generateJpegData(width: number, height: number): Buffer {
    // 使用一个有效的1x1像素JPEG文件的二进制数据
    const validJpegData = Buffer.from([
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
      0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
      0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
      0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
      0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
      0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
      0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
      0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x01,
      0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
      0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFF, 0xC4,
      0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C,
      0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0x80, 0xFF, 0xD9
    ]);
    
    return validJpegData;
  }

  /**
   * 生成WebP数据（简化版）
   */
  private generateWebpData(width: number, height: number): Buffer {
    // WebP文件头
    const webpHeader = Buffer.from([
      0x52, 0x49, 0x46, 0x46, // RIFF
      0x00, 0x00, 0x00, 0x00, // File size (placeholder)
      0x57, 0x45, 0x42, 0x50, // WEBP
      0x56, 0x50, 0x38, 0x20, // VP8
      0x00, 0x00, 0x00, 0x00  // Chunk size (placeholder)
    ]);
    
    // 简化的图像数据
    const imageData = Buffer.alloc(width * height / 10, 0x80);
    
    return Buffer.concat([webpHeader, imageData]);
  }

  /**
   * 生成GIF数据（简化版）
   */
  private generateGifData(width: number, height: number): Buffer {
    // GIF文件头
    const gifHeader = Buffer.from([
      0x47, 0x49, 0x46, 0x38, 0x39, 0x61, // GIF89a
      width & 0xFF, (width >> 8) & 0xFF,   // Width
      height & 0xFF, (height >> 8) & 0xFF, // Height
      0x80, 0x00, 0x00 // Global color table flag, background, aspect ratio
    ]);
    
    // 简化的颜色表和图像数据
    const colorTable = Buffer.alloc(6, 0x80); // 简单的颜色表
    const imageData = Buffer.from([0x2C, 0x00, 0x00, 0x00, 0x00]); // 图像描述符
    const endMarker = Buffer.from([0x3B]); // GIF结束标记
    
    return Buffer.concat([gifHeader, colorTable, imageData, endMarker]);
  }

  /**
   * 获取文件大小（MB）
   */
  getFileSizeInMB(filePath: string): number {
    const stats = fs.statSync(filePath);
    return stats.size / (1024 * 1024);
  }

  /**
   * 清理所有测试文件
   */
  cleanupTestFiles() {
    if (fs.existsSync(this.fixturesDir)) {
      const files = fs.readdirSync(this.fixturesDir);
      for (const file of files) {
        const filePath = path.join(this.fixturesDir, file);
        if (fs.statSync(filePath).isFile()) {
          fs.unlinkSync(filePath);
        }
      }
    }
  }

  /**
   * 创建标准测试图片集
   */
  createStandardTestImages() {
    return {
      smallPng: this.createPngImage('test-small.png', 100, 100),
      mediumJpeg: this.createJpegImage('test-medium.jpg', 500, 500),
      largeWebp: this.createWebpImage('test-large.webp', 1000, 1000),
      animatedGif: this.createGifImage('test-animated.gif', 200, 200),
      oversizedFile: this.createLargeImage('test-oversize.png', 15),
      invalidFormat: this.createInvalidFormatFile('test-invalid.png')
    };
  }
}