"use client"

import React, { useState, useEffect, useCallback } from 'react';
import { motion } from 'framer-motion';
import { ImageData, Tag, SearchFilters, Prompt } from '@/types';
import { ApiClient } from '@/lib/api';
import IndexedDBManager from '@/lib/indexed-db';
import { filterImages, copyToClipboard } from '@/lib/utils';
import { ListenerManager } from '@/lib/listeners';
import { SearchBar } from '@/components/search-bar';
import { ImageGrid } from '@/components/image-grid';
import { ImageModal } from '@/components/image-modal';
import { UploadModal } from '@/components/upload-modal';
import { Dock } from '@/components/dock';
import { ConnectionStatus } from '@/components/connection-status';
import TextPressure from '@/components/text-pressure';
import CircularText from '@/components/circular-text';
import { DownloadProgressToast, useDownloadProgress } from '@/components/download-progress-toast';

// ‰∏ªÈ°µÈù¢ÁªÑ‰ª∂
export default function HomePage() {
  // Áä∂ÊÄÅÁÆ°ÁêÜ
  const [images, setImages] = useState<ImageData[]>([]);
  const [filteredImages, setFilteredImages] = useState<ImageData[]>([]);
  const [tags, setTags] = useState<Tag[]>([]);
  const [selectedImage, setSelectedImage] = useState<ImageData | null>(null);
  const [searchFilters, setSearchFilters] = useState<SearchFilters>({
    query: '',
    tags: [],
    sortBy: 'createdAt',
    sortOrder: 'desc'
  });
  const [isLoading, setIsLoading] = useState(true);
  const [isImageModalOpen, setIsImageModalOpen] = useState(false);
  const [isUploadModalOpen, setIsUploadModalOpen] = useState(false);
  const [activeView, setActiveView] = useState('grid');
  const [connectionStatus, setConnectionStatus] = useState<'connected' | 'disconnected' | 'reconnecting'>('connected');
  const [isEditMode, setIsEditMode] = useState(false);
  const [selectedImageIds, setSelectedImageIds] = useState<Set<string>>(new Set());
  
  // ‰∏ãËΩΩËøõÂ∫¶ÁÆ°ÁêÜ
  const {
    isVisible: isDownloadVisible,
    progress: downloadProgress,
    startDownload,
    updateProgress,
    completeDownload,
    errorDownload,
    hideToast: hideDownloadToast
  } = useDownloadProgress();

  // ESCÈîÆÈÄÄÂá∫ÁºñËæëÊ®°Âºè
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && isEditMode) {
        setIsEditMode(false);
        setSelectedImageIds(new Set());
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [isEditMode]);

  // ÂàùÂßãÂåñÂÆûÊó∂ÁõëÂê¨
  useEffect(() => {
    console.log('üöÄ ÂàùÂßãÂåñÂÆûÊó∂Êï∞ÊçÆÁõëÂê¨...');
    
    // ÁõëÂê¨ÂõæÁâáÊï∞ÊçÆÂèòÂåñ
    const unsubscribeImages = ListenerManager.subscribeToImages((newImages) => {
      console.log('üì∏ ÂõæÁâáÊï∞ÊçÆÊõ¥Êñ∞:', newImages.length, 'Âº†ÂõæÁâá');
      setImages(newImages);
      setIsLoading(false);
      setConnectionStatus('connected');
    });

    // ÁõëÂê¨Ê†áÁ≠æÊï∞ÊçÆÂèòÂåñ
    const unsubscribeTags = ListenerManager.subscribeToTags((newTags) => {
      console.log('üè∑Ô∏è Ê†áÁ≠æÊï∞ÊçÆÊõ¥Êñ∞:', newTags.length, '‰∏™Ê†áÁ≠æ');
      setTags(newTags);
    });

    // ÁõëÂê¨ÁΩëÁªúÁä∂ÊÄÅ
    const handleOnline = () => {
      console.log('üåê ÁΩëÁªúÂ∑≤ËøûÊé•');
      setConnectionStatus('connected');
    };

    const handleOffline = () => {
      console.log('üîå ÁΩëÁªúÂ∑≤Êñ≠ÂºÄ');
      setConnectionStatus('disconnected');
    };

    if (typeof window !== 'undefined') {
      window.addEventListener('online', handleOnline);
      window.addEventListener('offline', handleOffline);
    }

    // Ê∏ÖÁêÜÂáΩÊï∞
    return () => {
      console.log('üßπ Ê∏ÖÁêÜÁõëÂê¨Âô®...');
      ListenerManager.unregisterAllListeners();
      if (typeof window !== 'undefined') {
        window.removeEventListener('online', handleOnline);
        window.removeEventListener('offline', handleOffline);
      }
    };
  }, []);

  // ÂêéÂè∞ÂêåÊ≠• IndexedDB Âà∞ Firestore
  useEffect(() => {
    const syncInterval = setInterval(async () => {
      console.log('üîÑ Ê£ÄÊü• IndexedDB ‰∏≠ÁöÑÂæÖ‰∏ä‰º†ÂõæÁâá...');
      const imagesToUpload = await IndexedDBManager.getImages();
      const pendingImages = imagesToUpload.filter(img => !img.is_valid);

      if (pendingImages.length > 0) {
        console.log(`üì§ ÂèëÁé∞ ${pendingImages.length} Âº†ÂæÖ‰∏ä‰º†ÂõæÁâáÔºåÂºÄÂßãÂêåÊ≠•...`);
        for (const image of pendingImages) {
          try {
            // Â∞Ü base64 ËΩ¨Êç¢Âõû File ÂØπË±°
            const res = await fetch(image.image_data);
            const blob = await res.blob();
            const file = new File([blob], image.image_name, { type: blob.type });

            const result = await ApiClient.addImage(file, image.description, image.tags.join(','));
            if (result.success && result.data) {
              console.log(`‚úÖ ÂõæÁâá ${image.image_name} ÂêåÊ≠•ÊàêÂäü`);
              // Áî®ÊúçÂä°Âô®ËøîÂõûÁöÑÊï∞ÊçÆÊõøÊç¢Êú¨Âú∞‰∏¥Êó∂Êï∞ÊçÆ
              setImages(prevImages => 
                prevImages.map(prevImage => 
                  prevImage.id === image.id ? { ...result.data!, isLocal: false } : prevImage
                )
              );
              // ‰ªé IndexedDB ‰∏≠Âà†Èô§
              await IndexedDBManager.deleteImage(image.id);
            } else {
              console.error(`‚ùå ÂõæÁâá ${image.image_name} ÂêåÊ≠•Â§±Ë¥•:`, result.error);
            }
          } catch (error) {
            console.error(`‚ùå ÂêåÊ≠•ÂõæÁâá ${image.image_name} Êó∂Âá∫Èîô:`, error);
          }
        }
      } else {
        console.log('‚úÖ Êó†ÂæÖ‰∏ä‰º†ÂõæÁâá');
      }
    }, 30000); // ÊØè30ÁßíÊ£ÄÊü•‰∏ÄÊ¨°

    return () => clearInterval(syncInterval);
  }, []);

  // ÊâãÂä®Âà∑Êñ∞Êï∞ÊçÆÔºàÂ§áÁî®ÊñπÊ≥ïÔºâ
  const refreshData = async () => {
    console.log('üîÑ ÊâãÂä®Âà∑Êñ∞Êï∞ÊçÆ...');
    setConnectionStatus('reconnecting');
    try {
      const [imagesResult, tagsResult] = await Promise.all([
        ApiClient.getAllImages(),
        ApiClient.getAllTags()
      ]);
      
      if (imagesResult.success && imagesResult.data) {
        setImages(imagesResult.data);
        console.log('üì∏ ÊâãÂä®Âà∑Êñ∞ÂõæÁâáÊàêÂäü');
      }
      
      if (tagsResult.success && tagsResult.data) {
        setTags(tagsResult.data);
        console.log('üè∑Ô∏è ÊâãÂä®Âà∑Êñ∞Ê†áÁ≠æÊàêÂäü');
      }
      
      setConnectionStatus('connected');
    } catch (error) {
      console.error('ÊâãÂä®Âà∑Êñ∞Êï∞ÊçÆÂ§±Ë¥•:', error);
      setConnectionStatus('disconnected');
    }
  };

  // Ëé∑ÂèñÁõëÂê¨Âô®Áä∂ÊÄÅ
  const getConnectionInfo = () => {
    const status = ListenerManager.getListenerStatus();
    console.log('üìä ÁõëÂê¨Âô®Áä∂ÊÄÅ:', status);
    return status;
  };

  // ÊêúÁ¥¢ÂíåÁ≠õÈÄâÂõæÁâáÔºàÂâçÁ´ØÊêúÁ¥¢Ôºâ
  useEffect(() => {
    const filtered = filterImages(images, searchFilters);
    setFilteredImages(filtered);
  }, [images, searchFilters]);

  // Â§ÑÁêÜÊêúÁ¥¢ÂèòÂåñÔºàÂâçÁ´ØÊêúÁ¥¢Ôºâ
  const handleSearchChange = useCallback((filters: SearchFilters) => {
    setSearchFilters(filters);
  }, []);

  // Â§ÑÁêÜÂõæÁâáÁÇπÂáª
  const handleImageClick = useCallback((image: ImageData) => {
    setSelectedImage(image);
    setIsImageModalOpen(true);
  }, []);

  // Â§ÑÁêÜÂõæÁâáÊõ¥Êñ∞
  const handleImageUpdate = useCallback(async (id: string, updates: Partial<ImageData>) => {
    console.log('üîÑ Êõ¥Êñ∞ÂõæÁâá:', id, updates);
    const result = await ApiClient.updateImage(id, updates);
    
    if (result.success) {
      console.log('‚úÖ ÂõæÁâáÊõ¥Êñ∞ÊàêÂäüÔºåÂÆûÊó∂ÁõëÂê¨Âô®Â∞ÜËá™Âä®Êõ¥Êñ∞UI');
      // ÂÆûÊó∂ÁõëÂê¨Âô®‰ºöËá™Âä®Êõ¥Êñ∞imagesÁä∂ÊÄÅÔºåÊó†ÈúÄÊâãÂä®Êõ¥Êñ∞
      
      // Êõ¥Êñ∞ÈÄâ‰∏≠ÁöÑÂõæÁâáÔºàÂ¶ÇÊûúÊ≠£Âú®Êü•ÁúãÔºâ
      if (selectedImage?.id === id && result.data) {
        setSelectedImage(result.data);
      }
    } else {
      console.error('‚ùå ÂõæÁâáÊõ¥Êñ∞Â§±Ë¥•:', result.error);
      throw new Error(result.error || 'Êõ¥Êñ∞Â§±Ë¥•');
    }
  }, [selectedImage]);

  // Â§ÑÁêÜÂõæÁâá‰∏ä‰º†
  const handleImageUpload = useCallback(async (file: File, imageName: string, prompts: Prompt[], tags: Tag[]) => {
    console.log('üì§ Â§ÑÁêÜÂõæÁâá‰∏ä‰º†:', imageName);
    try {
      // Â¶ÇÊûúÂú®Á∫øÔºåÁõ¥Êé•‰∏ä‰º†Âà∞ÊúçÂä°Âô®
      if (connectionStatus === 'connected') {
        // Â∞ÜÊñ∞ÁöÑÊï∞ÊçÆÁªìÊûÑËΩ¨Êç¢‰∏∫APIÊúüÊúõÁöÑÊ†ºÂºè
        const tagsString = tags.map(tag => tag.name).join(',');
        const result = await ApiClient.addImage(file, imageName, tagsString);
        if (result.success && result.data) {
          // ‰∏ä‰º†ÊàêÂäüÂêéÔºåÊõ¥Êñ∞ÂõæÁâáÁöÑÊèêÁ§∫ËØçÂùó
          if (prompts.length > 0) {
            const updateResult = await ApiClient.updateImage(result.data.id, {
              prompts: prompts
            });
            if (!updateResult.success) {
              console.warn('‚ö†Ô∏è ÊèêÁ§∫ËØçÂùóÊõ¥Êñ∞Â§±Ë¥•:', updateResult.error);
            }
          }
          console.log('‚úÖ ÂõæÁâá‰∏ä‰º†ÊàêÂäü:', result.data);
        } else {
          throw new Error(result.error || '‰∏ä‰º†Â§±Ë¥•');
        }
      } else {
        // Â¶ÇÊûúÁ¶ªÁ∫øÔºåÂ≠òÂÇ®Âà∞IndexedDB
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = async () => {
          const base64 = reader.result as string;
          const tempId = `temp_${Date.now()}`;

          const localImageData: ImageData = {
            id: tempId,
            url: base64,
            title: imageName,
            tags: tags,
            prompts: prompts,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            isLocal: true,
          };

          // Á´ãÂç≥Êõ¥Êñ∞UI
          setImages(prevImages => [localImageData, ...prevImages]);

          // Â≠òÂÖ•IndexedDB‰ª•Â§áÂêéÂè∞ÂêåÊ≠•
          const dbImageData = {
            id: tempId,
            image_name: file.name,
            image_data: base64,
            tags: tags.map(tag => tag.name),
            upload_time: new Date(),
            description: imageName,
            is_valid: false,
            prompt_blocks: prompts,
          };

          try {
            await IndexedDBManager.addImage(dbImageData);
            console.log('‚úÖ ÂõæÁâáÂ∑≤ÊöÇÂ≠òÂà∞ IndexedDB');
          } catch (error) {
            console.error('‚ùå ÊöÇÂ≠òÂõæÁâáÂà∞ IndexedDB Â§±Ë¥•:', error);
            setImages(prev => prev.filter(img => img.id !== tempId));
          }
        };
      }
    } catch (error) {
      console.error('‚ùå ‰∏ä‰º†Â§±Ë¥•:', error);
      throw error;
    }
  }, [connectionStatus]);

  // Â§ÑÁêÜÊ†áÁ≠æÂàõÂª∫
  const handleTagCreate = useCallback(async (tagData: Omit<Tag, 'id'>) => {
    console.log('üè∑Ô∏è ÂàõÂª∫Ê†áÁ≠æ:', tagData.name);
    const result = await ApiClient.addTag(tagData);
    
    if (result.success && result.data) {
      console.log('‚úÖ Ê†áÁ≠æÂàõÂª∫ÊàêÂäüÔºåÂÆûÊó∂ÁõëÂê¨Âô®Â∞ÜËá™Âä®Êõ¥Êñ∞UI');
      // ÂÆûÊó∂ÁõëÂê¨Âô®‰ºöËá™Âä®Êõ¥Êñ∞tagsÁä∂ÊÄÅÔºåÊó†ÈúÄÊâãÂä®Êõ¥Êñ∞
      return result.data;
    } else {
      console.error('‚ùå Ê†áÁ≠æÂàõÂª∫Â§±Ë¥•:', result.error);
      throw new Error(result.error || 'ÂàõÂª∫Â§±Ë¥•');
    }
  }, []);

  // Â§ÑÁêÜÊèêÁ§∫ËØçÂ§çÂà∂
  const handleCopyPrompt = useCallback(async (content: string) => {
    try {
      await copyToClipboard(content);
      // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†ÊàêÂäüÊèêÁ§∫
    } catch (error) {
      console.error('Â§çÂà∂Â§±Ë¥•:', error);
    }
  }, []);

  // Â§ÑÁêÜÂõæÁâáÂà†Èô§
  const handleImageDelete = useCallback(async (id: string) => {
    console.log('üóëÔ∏è Âà†Èô§ÂõæÁâá:', id);
    const result = await ApiClient.deleteImage(id);
    
    if (result.success) {
      console.log('‚úÖ ÂõæÁâáÂà†Èô§ÊàêÂäüÔºåÂÆûÊó∂ÁõëÂê¨Âô®Â∞ÜËá™Âä®Êõ¥Êñ∞UI');
      // ÂÆûÊó∂ÁõëÂê¨Âô®‰ºöËá™Âä®Êõ¥Êñ∞imagesÁä∂ÊÄÅÔºåÊó†ÈúÄÊâãÂä®Êõ¥Êñ∞
      // ÂÖ≥Èó≠ÂºπÁ™ó
      setIsImageModalOpen(false);
      setSelectedImage(null);
    } else {
      console.error('‚ùå ÂõæÁâáÂà†Èô§Â§±Ë¥•:', result.error);
      throw new Error(result.error || 'Âà†Èô§Â§±Ë¥•');
    }
  }, []);

  // Â§ÑÁêÜÂõæÁâáÂ§çÂà∂
  const handleImageDuplicate = useCallback(async (image: ImageData) => {
    try {
      // Â§çÂà∂ÂäüËÉΩÊöÇÊó∂Á¶ÅÁî®ÔºåÂõ†‰∏∫ÈúÄË¶ÅÈáçÊñ∞‰∏ä‰º†Êñá‰ª∂
      console.log('Â§çÂà∂ÂäüËÉΩÂºÄÂèë‰∏≠...');
      alert('Â§çÂà∂ÂäüËÉΩÂºÄÂèë‰∏≠ÔºåËØ∑ÊâãÂä®ÈáçÊñ∞‰∏ä‰º†ÂõæÁâá');
    } catch (error) {
      console.error('Â§çÂà∂ÂõæÁâáÂ§±Ë¥•:', error);
      throw error;
    }
  }, []);

  // Dock ÂØºËà™Â§ÑÁêÜÂáΩÊï∞
  const handleUpload = useCallback(() => {
    setIsUploadModalOpen(true);
  }, []);

  const handleImport = useCallback(() => {
    setIsEditMode(!isEditMode);
    if (isEditMode) {
      // ÈÄÄÂá∫ÁºñËæëÊ®°ÂºèÊó∂Ê∏ÖÁ©∫ÈÄâÊã©
      setSelectedImageIds(new Set());
    }
  }, [isEditMode]);

  const handleExport = useCallback(async () => {
    alert('ÊöÇÊó∂Ê≤°Áî®Ôºå‰∏∫‰∫ÜÂØπÁß∞');
  }, []);
  
  // ËæÖÂä©ÂáΩÊï∞Ôºö‰ªéURLËé∑ÂèñÊñá‰ª∂Êâ©Â±ïÂêç
  const getFileExtensionFromUrl = (url: string): string => {
    try {
      const pathname = new URL(url).pathname;
      const extension = pathname.split('.').pop();
      return extension || 'jpg';
    } catch {
      return 'jpg';
    }
  };

  const handleFavorites = useCallback(() => {
    setActiveView('favorites');
    // Á≠õÈÄâÊî∂ËóèÁöÑÂõæÁâá
    setSearchFilters(prev => ({
      ...prev,
      query: '',
      tags: [],
      isFavorite: true
    }));
  }, []);

  const handleSettings = useCallback(() => {
    setActiveView('settings');
    // ËøôÈáåÂèØ‰ª•ÊâìÂºÄËÆæÁΩÆÂºπÁ™ó
  }, []);

  const handleLarkDoc = useCallback(() => {
    window.open('https://bytedance.larkoffice.com/wiki/HNHvwAjVzicLVuk1r5ictnNKncg', '_blank');
  }, []);

  // Â§ÑÁêÜÊ†áÁ≠æÂà†Èô§
  const handleTagDelete = useCallback(async (tagId: string) => {
    const confirmed = confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Ê†áÁ≠æÂêóÔºüÂà†Èô§ÂêéÂ∞Ü‰ªéÊâÄÊúâÂõæÁâá‰∏≠ÁßªÈô§„ÄÇ');
    if (!confirmed) return;

    try {
      const result = await ApiClient.deleteTag(tagId);
      if (result.success) {
        console.log('‚úÖ Ê†áÁ≠æÂà†Èô§ÊàêÂäüÔºåÂÆûÊó∂ÁõëÂê¨Âô®Â∞ÜËá™Âä®Êõ¥Êñ∞UI');
        // ÂÆûÊó∂ÁõëÂê¨Âô®‰ºöËá™Âä®Êõ¥Êñ∞tagsÁä∂ÊÄÅÔºåÊó†ÈúÄÊâãÂä®Êõ¥Êñ∞
      } else {
        console.error('‚ùå Ê†áÁ≠æÂà†Èô§Â§±Ë¥•:', result.error);
        alert('Âà†Èô§Ê†áÁ≠æÂ§±Ë¥•: ' + (result.error || 'Êú™Áü•ÈîôËØØ'));
      }
    } catch (error) {
      console.error('‚ùå Âà†Èô§Ê†áÁ≠æÊó∂Âá∫Èîô:', error);
      alert('Âà†Èô§Ê†áÁ≠æÂ§±Ë¥•: ' + (error as Error).message);
    }
  }, []);

  // ÊâπÈáèÊìç‰ΩúÂ§ÑÁêÜÂáΩÊï∞
  const handleSelectImage = useCallback((imageId: string, selected: boolean) => {
    setSelectedImageIds(prev => {
      const newSet = new Set(prev);
      if (selected) {
        newSet.add(imageId);
      } else {
        newSet.delete(imageId);
      }
      return newSet;
    });
  }, []);

  const handleSelectAll = useCallback(() => {
    if (selectedImageIds.size === filteredImages.length) {
      // Â¶ÇÊûúÂ∑≤ÂÖ®ÈÄâÔºåÂàôÂèñÊ∂àÂÖ®ÈÄâ
      setSelectedImageIds(new Set());
    } else {
      // Âê¶ÂàôÂÖ®ÈÄâ
      setSelectedImageIds(new Set(filteredImages.map(img => img.id)));
    }
  }, [selectedImageIds.size, filteredImages]);

  const handleBatchDelete = useCallback(async () => {
    if (selectedImageIds.size === 0) return;
    
    const confirmed = confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${selectedImageIds.size} Âº†ÂõæÁâáÂêóÔºü`);
    if (!confirmed) return;

    try {
      const deletePromises = Array.from(selectedImageIds).map(id => ApiClient.deleteImage(id));
      await Promise.all(deletePromises);
      setSelectedImageIds(new Set());
      console.log('‚úÖ ÊâπÈáèÂà†Èô§ÊàêÂäü');
    } catch (error) {
      console.error('‚ùå ÊâπÈáèÂà†Èô§Â§±Ë¥•:', error);
      alert('ÊâπÈáèÂà†Èô§Â§±Ë¥•: ' + (error as Error).message);
    }
  }, [selectedImageIds]);



  const handleBatchExport = useCallback(async () => {
    if (selectedImageIds.size === 0) return;

    try {
      const selectedImages = filteredImages.filter(img => selectedImageIds.has(img.id));

      // ÂØºÂá∫ÂõæÁâá
      for (let i = 0; i < selectedImages.length; i++) {
        const image = selectedImages[i];
        if (!image.url) continue;

        try {
          const imgElements = document.querySelectorAll('img');
          let cachedImg: HTMLImageElement | null = null;

          for (let j = 0; j < imgElements.length; j++) {
            const imgEl = imgElements[j];
            if (imgEl.src === image.url) {
              cachedImg = imgEl;
              break;
            }
          }

          let blob: Blob;

          if (cachedImg && cachedImg.complete) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = cachedImg.naturalWidth;
            canvas.height = cachedImg.naturalHeight;
            ctx?.drawImage(cachedImg, 0, 0);
            blob = await new Promise<Blob>((resolve) => {
              canvas.toBlob((blob) => {
                resolve(blob!);
              }, 'image/png');
            });
          } else {
            const response = await fetch(image.url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            blob = await response.blob();
          }

          const extension = getFileExtensionFromUrl(image.url);
          const filename = `${image.title || `image-${image.id}`}.${extension}`;

          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          if (i < selectedImages.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        } catch (error) {
          console.error(`‚ùå ‰∏ãËΩΩÂõæÁâá ${image.title || image.id} Â§±Ë¥•:`, error);
        }
      }

      // ÂØºÂá∫JSONÊï∞ÊçÆ
      const exportData = {
        images: selectedImages,
        tags: tags.filter(tag =>
          selectedImages.some(img =>
            img.tags.some(imgTag =>
              typeof imgTag === 'string' ? imgTag === tag.name : imgTag.id === tag.id
            )
          )
        ),
        exportTime: new Date().toISOString(),
        totalCount: selectedImages.length
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `selected-images-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      alert(`Â∑≤ÂºÄÂßã‰∏ãËΩΩ ${selectedImages.length} Âº†ÂõæÁâáÂπ∂ÂØºÂá∫JSONÊï∞ÊçÆ`);
    } catch (error) {
      console.error('‚ùå ÊâπÈáèÂØºÂá∫Â§±Ë¥•:', error);
      alert('ÊâπÈáèÂØºÂá∫Â§±Ë¥•: ' + (error as Error).message);
    }
  }, [selectedImageIds, filteredImages, tags, getFileExtensionFromUrl]);

  // ÂÖ≥Èó≠ÂõæÁâáËØ¶ÊÉÖÂºπÁ™ó
  const closeImageModal = useCallback(() => {
    setIsImageModalOpen(false);
    setSelectedImage(null);
  }, []);

  // ÂÖ≥Èó≠‰∏ä‰º†ÂºπÁ™ó
  const closeUploadModal = useCallback(() => {
    setIsUploadModalOpen(false);
  }, []);

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center">
          <CircularText
            text="LOADING ‚Ä¢ LOADING ‚Ä¢ "
            spinDuration={3}
            onHover={null}
            className="text-primary mb-4"
          />
          <p className="text-muted-foreground"></p>
        </div>
      </div>
    );
  }

  return (
    <>
      {/* ËøûÊé•Áä∂ÊÄÅÊåáÁ§∫Âô® */}
      <ConnectionStatus
        status={connectionStatus}
        onRefresh={refreshData}
      />
      
      <div className="flex justify-center w-full ">
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="w-3/5"
        >
          <div className="text-center ">
           <p className="text-sm text-gray-300 mt-20">
              Manage your images and prompt words to make creation more efficient.
            </p>
            <div className="h-auto mb-1 ">
              <TextPressure
                text="GoooodCase!"
                fontFamily="Inter"
                textColor="#000"
                className="text-4xl font-bold"
                minFontSize={32} />
            </div>
             
          </div>
        </motion.div>
      </div>
      
      <div className="min-h-screen  bg-background">
        {/* ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü */}
        <div className="w-[70%] mx-auto px-4 mb-4 pb-24 mt-10">
          {/* ÊêúÁ¥¢Ê†è
          {!isEditMode && (
            <SearchBar
              onSearch={setSearchFilters}
              selectedTags={searchFilters.tags}
              onTagsChange={(tags) => setSearchFilters(prev => ({ ...prev, tags }))}
              availableTags={tags} />
          )} */}
          
          {/* ÊâπÈáèÊìç‰ΩúÂ∑•ÂÖ∑Ê†è */}
          {isEditMode && (
            <motion.div
              initial={{ opacity: 0, y: -20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              className="mb-6 p-4 bg-muted rounded-2xl border mt-10"
            >
              <div className="flex items-center justify-between flex-wrap gap-4">
                <div className="flex items-center gap-4">
                  <span className="text-sm font-medium">
                    Â∑≤ÈÄâÊã© {selectedImageIds.size} Âº†ÂõæÁâá
                  </span>
                  <button
                    onClick={handleSelectAll}
                    className="text-sm text-primary hover:underline"
                  >
                    {selectedImageIds.size === filteredImages.length ? 'ÂèñÊ∂àÂÖ®ÈÄâ' : 'ÂÖ®ÈÄâ'}
                  </button>
                </div>
                <div className="flex items-center gap-2 rounded-2xl">
                  <button
                    onClick={handleBatchExport}
                    disabled={selectedImageIds.size === 0}
                    className="px-4 py-2 text-sm bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200"
                  >
                    ÂØºÂá∫
                  </button>
                  <button
                    onClick={handleBatchDelete}
                    disabled={selectedImageIds.size === 0}
                    className="px-4 py-2 text-sm bg-destructive text-destructive-foreground rounded-lg hover:bg-destructive/90 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200"
                  >
                    Âà†Èô§
                  </button>
                </div>
              </div>
            </motion.div>
          )}

          {/* Ê†áÁ≠æÁÆ°ÁêÜÂå∫Âüü
          {isEditMode && (
            <motion.div
              initial={{ opacity: 0, y: -20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              className="mb-6 p-4 bg-muted rounded-2xl border"
            >
              <div className="flex gap-3  mb-3">
                <h3 className="text-sm font-medium text-foreground mb-2">Ê†áÁ≠æÁÆ°ÁêÜ</h3>
                <p className="text-xs text-muted-foreground">ÁÇπÂáªÂà†Èô§ÊåâÈíÆÂèØ‰ª•Ê∏ÖÈô§Êó†Áî®ÁöÑÊ†áÁ≠æ</p>
              </div>
              {tags.length > 0 ? (
                <div className="flex flex-wrap gap-2">
                  {tags.map((tag) => (
                    <div
                      key={tag.id}
                      className="flex items-center gap-2 px-3 py-1 bg-background rounded-full border text-sm"
                    >
                      <span className="text-foreground">{tag.name}</span>
                      <button
                        onClick={() => handleTagDelete(tag.id)}
                        className="text-destructive hover:text-destructive/80 transition-colors duration-200"
                        title="Âà†Èô§Ê†áÁ≠æ"
                      >
                        √ó
                      </button>
                    </div>
                  ))}
                </div>
              ) : (
                <p className="text-sm text-muted-foreground">ÊöÇÊó†Ê†áÁ≠æ</p>
              )}
            </motion.div>
          )} */}
          
          {/* ÂõæÁâáÁΩëÊ†º */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5, delay: 0.2 }}
          >
            <ImageGrid
              images={filteredImages}
              loading={isLoading}
              onImageClick={handleImageClick}
              isEditMode={isEditMode}
              selectedImageIds={selectedImageIds}
              onSelectImage={handleSelectImage} />
          </motion.div>

          {/* ÁªüËÆ°‰ø°ÊÅØ */}
          {filteredImages.length > 0 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.5, delay: 0.4 }}
              className="mt-20 text-center text-sm text-muted-foreground"
            >
              ÂÖ±ÊâæÂà∞ {filteredImages.length} Âº†ÂõæÁâá
              {searchFilters.query && (
                <span> ¬∑ ÊêúÁ¥¢: "{searchFilters.query}"</span>
              )}
              {searchFilters.tags.length > 0 && (
                <span> ¬∑ Ê†áÁ≠æ: {searchFilters.tags.map(tag => typeof tag === 'string' ? tag : tag.name).join(', ')}</span>
              )}
            </motion.div>
          )}
        </div>

        {/* Â∫ïÈÉ® Dock ÂØºËà™ */}
        <Dock
          onUpload={handleUpload}
          onImport={handleImport}
          onExport={handleExport}
          onFavorites={handleFavorites}
          onSettings={handleSettings}
          onLarkDoc={handleLarkDoc}
          onEdit={handleImport}
          isEditMode={isEditMode}
          onSearch={handleSearchChange}
          selectedTags={searchFilters.tags}
          onTagsChange={(tags) => setSearchFilters(prev => ({ ...prev, tags }))}
          availableTags={tags}
          searchQuery={searchFilters.query}
          onSearchQueryChange={(query) => setSearchFilters(prev => ({ ...prev, query }))}
        />

        {/* ÂõæÁâáËØ¶ÊÉÖÂºπÁ™ó */}
        <ImageModal
          image={selectedImage}
          isOpen={isImageModalOpen}
          onClose={closeImageModal}
          onUpdate={handleImageUpdate}
          onDelete={handleImageDelete}
          onDuplicate={handleImageDuplicate}
          availableTags={tags}
          onCreateTag={handleTagCreate}
          onCopyPrompt={handleCopyPrompt} />

        {/* ‰∏ä‰º†ÂõæÁâáÂºπÁ™ó */}
        <UploadModal
          isOpen={isUploadModalOpen}
          onClose={closeUploadModal}
          onUpload={handleImageUpload}
          availableTags={tags}
          onCreateTag={handleTagCreate} />
        
        {/* ‰∏ãËΩΩËøõÂ∫¶Toast */}
        <DownloadProgressToast
          isVisible={isDownloadVisible}
          progress={downloadProgress}
          onClose={hideDownloadToast}
        />
      </div>
    </>
  );
}